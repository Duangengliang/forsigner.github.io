<!doctype html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  
  <title>归档：2013 | forsigner</title>
  <meta name="author" content="forisnger">
  
  <meta name="description" content="前端&amp;设计">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="forsigner"/>

  
    <meta property="og:image" content="undefined"/>
  

    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="alternate" href="/atom.xml" title="forsigner" type="application/atom+xml">
  <link rel="stylesheet" href="/css/bootstrap-2.3.2.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="/js/modernizr.js"></script>

<link rel="stylesheet/less" type="text/css" href="/less/style.less" />


  <script src="/js/less-1.3.3.min.js"></script>



</head>


<body>
    <section class="left">
        <div class="sidebar">
            <header id="header" class="header"><div class="blog-info">
    <div class="wrap-logo">
        <a href="/">
            <div class="blog-logo dib">
                <div class="circle"></div>
                <div class="line"></div>
            </div>
            <div class="blog-name dib">forsigner</div>
        </a>
    </div>
    <!--
    <aside class="blog-desc">前端&amp;设计</aside>
    -->
</div>
</header>
            <aside><nav id="nav" class="nav">
    <ul>
        
    </ul>
</nav>

  
<div class="widget tag">
  <ul>
  
    <li><a href="/tags/CSS/">CSS</a></li>
  
    <li><a href="/tags/JavaSctipt/">JavaSctipt</a></li>
  
    <li><a href="/tags/前端工具/">前端工具</a></li>
  
    <li><a href="/tags/设计/">设计</a></li>
  
    <li><a href="/tags/读书/">读书</a></li>
  
    <li><a href="/tags/随记/">随记</a></li>
  
  </ul>
</div>



</aside>
        </div>
    </section>
    <section class="right">
        <div id="content" class="inner">
            <div class="wrap-post">
<h2 class="archive-title">2013</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/04/19/gruntjs/">很好前端构建工具:Grunt</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-04-19T12:57:29.000Z">4月19 2013</time>
      
    </header>
    <div class="entry">
      
        <p>Grunt 是一个基于任务的命令行构建工具，非常适用于JavaScript项目中。简单的说，grunt像是前端人员的工具箱，里面提供各种各样的工具来实现不同的功能，如合并文件、压缩文件、单元测试等，而且这些操作可以完全实现自动化，给项目的管理和部署提供了极大的方便。好吧，不去吹捧它有多优秀了，看看它
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2013/04/19/gruntjs/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/03/28/inline-block/">关于inline-block最好的一篇文章</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-03-28T12:57:29.000Z">3月28 2013</time>
      
    </header>
    <div class="entry">
      
        <p>这是转自火枪手团队博客的一篇文章：inline-block 前世今生。
这是读过的关于inline-block最好的文章，如下：</p>
<p>曾几何时，display:inline-block 已经深入「大街小巷」，随处可见 「display:inline-block; <em>display:inline; </em>zoom:1; 」这样的代码。如今现代浏览器已经全面支持这个属性值了，上面的代码只是为了兼容 IE6、7 而已。那么你真的了解 inline-block 了吗？本文将带你深入剖析该属性值的前世今生，让你更好的理解和运用 inline-block。（本文约定 display:inline-block 简写为 inline-block）</p>
<p>开篇我们来看几个问题：</p>
<p>IE6、7 真的不支持 display:inline-block 吗？
display:inline-block 后的元素为什么会产生水平空隙，这真的是 bug 吗？
如何更好的解决 display:inline-block 元素间产生的水平空隙？
一、inline-block 前世</p>
<p>1.认知</p>
<p>也许有人问你为何要写「 display:inline-block; <em>display:inline; </em>zoom:1; 」 来兼容 IE6、7 时，你会立马答道：因为 IE6、7 不支持 display:inline-block 呗!不知道何时起，惯性思维给开发者带来了这样一个可怕的概念。万物都是辩证的，当你写下这些的时候，可曾怀疑过大众观点真的可靠吗？也许你认为这些无关 紧要，实现效果就好。但是如果不能理解每个属性或属性值的根本，你将永远无法全面的了解它，人云亦云只会让你浅尝辄止，止步不前。那么这里就涉及到所谓的 「CSS 学习瓶颈」的问题了，这个问题张鑫旭《说说CSS 学习中的瓶颈》一文有详细阐述，虽然部分观点我不是很赞同，但是中心思想还是很值得思考的。文中有几个不错的问题这里也列举出来供大家观摩：</p>
<p>line-height:150% 和 line-height:1.5 的区别是？
float 为何会让外部容器高度塌陷？这是 bug？（我的答案在《那些年我们一起清除过的浮动》）
vertical-align 的表现为何在IE7, IE8, IE9 下表现不尽相同？其中的渲染机制是？
好了，回到 inline-block 的认知的问题，我的观点是：</p>
<p>IE 从 5.5 开始就已经支持 display:inline-block 了，只是支持的并不是那么完善。</p>
<p>在 msdn 微软开发者社区，找到了 IE 从5.5 开始支持 inline-block 的证据：</p>
<p>The inline-block value is supported starting with Internet Explorer 5.5. You can use this value to give an object a layout without specifying the object’s height or width.</p>
<p>这里明确指出：从 IE5.5 开始支持 inline-block。</p>
<p>链接：<a href="http://msdn.microsoft.com/zh-cn/library/ie/ms530751(v=vs.85).aspx">http://msdn.microsoft.com/zh-cn/library/ie/ms530751(v=vs.85).aspx</a></p>
<p>那么既然 IE5.5 开始就已经支持了 inline-block，为何我们还要写那么一坨 CSS 呢？同时我们知道 IE6、7 中 display:inline-block 是可以触发 hasLayout 的，触发了 hasLayout 的元素表现出来的特征就是一个独立的矩形容器，可以设置宽高而且不受外部元素的影响，类似于现代浏览器中的 Block formatting contexts （块级格式化上下文）的概念。</p>
<p>下面来做一个详细的测试，分别看看 IE6 中 inline 元素和 block 元素的表现：</p>
<p>1）inline 元素 display:inline-block</p>
<p>IE6 中截图如下：</p>
<p>.dib-inline, .dib-block {
    width:100px;
    height:30px;
    line-height:30px;
    text-align:center;
}
.dib-inline {
    display:inline-block;&lt;
}
测试表明：IE6 中 inline 元素只要触发了 hasLayout 其表现就类似于 inline-block，这里设置 display:inline-block; 或者 zoom:1; 等其他属性值可以触发 hasLayout ，表现出来是一样的。</p>
<p>查看 DEMO</p>
<p>2）block 元素 display:inline-block</p>
<p>IE6 中截图如下：</p>
<p>.dib-inline, .dib-block {
    width:100px;
    height:30px;
    line-height:30px;
    text-align:center;
}
.dib-block{
    display:inline-block;
}
测试表明：IE6 中 block 元素即使触发了 hasLayout 也不能具有 inline-block 元素不换行的特性。想要 block 元素支持 inline-block 元素的特性，我们可以这样做：</p>
<p>.dib-block {
    display:inline;
    zoom:1;
}
首先让 block 元素转化为 inline 元素，强制其不换行；然后通过 zoom:1 触发 hasLayout，使其可以设置宽高。修复后的 截图如下：</p>
<p>3）结合现代浏览器</p>
<p>综上，现代浏览器都支持 display:inline-block ，IE6、7 inline 元素也可以达到同样的效果，IE6、7 block 元素需要设置 display:inline; zoom:1; 它们结合在一起便是：</p>
<p>display:inline-block; /<em> 现代浏览器 +IE6、7 inline 元素 </em>
<em>display:inline; /</em> IE6、7 block 元素 <em>
</em>zoom:1;
为了不让支持 CSS2.1 inline-block 的浏览器 重置为 inline，我们针对 IE6、7 做一个 hack。由于现代浏览器也开始支持 zoom 属性，这里只是希望 IE6、7 中生效，所以还是 hack 一下比较合适。至此产生了我们熟悉的兼容各个浏览器的 inline-block 写法。</p>
<p>小结：IE6、7 并不是不支持 inline-block，只是 block 元素需要做一些处理来达到 inline-block 的效果。</p>
<ol>
<li>到底什么是 inline-block</li>
</ol>
<p>说了很多，或许很多朋友还不是太明白到底什么是 inline-block？W3C 在 CSS2.1 The ‘display’ property 中描述如下：</p>
<p>This value causes an element to generate an inline-level block container. The inside of an inline-block is formatted as a block box, and the element itself is formatted as an atomic inline-level box.</p>
<p>大致意思就是：inline-block 后的元素创建了一个行级的块容器，该元素内部（内容）被格式化成一个块元素，同时元素本身则被格式化成一个行内元素。</p>
<p>直白一点的意思就是：inline-block 的元素既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，比如 inline-block 元素也可以设置 vertical-align 属性。简而言之：</p>
<p>inline-block 后的元素就是一个格式化为行内元素的块容器( Block container )</p>
<p>怎么样？听起来还不错吧！</p>
<ol>
<li>inline-block 缘从何起？</li>
</ol>
<p>前面已经证明了 IE 5.5 开始就支持了 inline-block，那么 IE5.5 是什么时候发布的呢？话说当年网景与 IE 大战，IE5.5 那是何等的风骚……（好吧，此处略去十页）。从维基百科的资料来看，IE5.5 beta1 的发布时间是：1999年12月，最终版本是 2000年7月。那么 W3C 标准中是何时才出现 inline-block 这个值的呢？</p>
<p>在 CSS1 规范中，「display」的值仅包括： block | inline | list-item | none 。CSS2.1中才添加了 inline-block 属性值。一丝继续舔着手指，用那苦逼的英语水平终于翻到了这份草案：<a href="http://www.w3.org/TR/2002/WD-CSS21-20020802/visuren.html#display-prop，">http://www.w3.org/TR/2002/WD-CSS21-20020802/visuren.html#display-prop，</a> 这份草案的日期是 2002年8月2日，纳尼！！！原来我们纠结了半天的 inline-block ， IE5.5 至少提前两年就提出来了啊！难道是微软给 W3C 提议后，CSS 2.1才加入的？（不过我看到 W3C 官网有一个关于是否增加 inline-block 的投票）好吧这个问题也许有一天 IE 某个开发者写《 IE回忆录》的时候我们才能了解到其中的内幕。如果找到更早关于 inline-block 的 CSS草案，也麻烦告知一丝一声。好吧，如果你还不相信，打微软官方电话问问吧 800-820-3800（不是 DHC 哦！）。</p>
<p>原来我们一直讨论的 inline-block 在 IE 6、7中和 CSS2.1 中的（现代浏览器所支持的） inline-block 上压根不是一个东东嘛，IE6、7 中的 inline-block 更像是 IE 的私有属性值，他们本身就不具有可比性。简单、绝对的认为 IE6、7 不支持 inline-block 好比一叶障目，看到前面，却看不到后面，太过于片面。诚然，IE6、7 的 hasLayout 给我们带来了很多麻烦，但是不得不承认微软的 IE 在网页多语言文本混排上的先进性，尤其是 CJK 文字和西文的混排，超越其他浏览器至少5年。</p>
<p>总结：</p>
<p>IE5.5 后开始支持 inline-block， 但是它所支持的 inline-block 不能等同于 CSS2.1 中的 inline-block，因为 IE5.5 比 CSS2.1 更早提出 inline-block 的概念并作为所谓的「私有属性值」使用，所以二者表现出来的效果是不完全一致。
IE 5.5、6、7 、8（Q）中 block 元素对 inline-block 支持不完整，如果要达到类似的效果，需要先设置为 display:inline，然后使用 zoom:1 等触发 hasLayout。
IE 5.5、6、7 、8（Q）中 inline 元素欲达到 inline-block 的效果只需直接设置此属性值或使用 zoom:1 等均可。
各浏览器对 display 属性的支持情况请参阅：《各浏览器对 ‘display’ 特性值的支持程度不同》</p>
<p>二、inline-block 今生</p>
<ol>
<li>display:inline-block 后的元素为什么会产生水平空隙，这真的是 bug 吗？</li>
</ol>
<p>这么一个神奇的属性，为何大家一直避而远之呢？这恐怕还得从 inline-block 元素之间产生的水平空隙（间隙）说起吧。</p>
<p>参照 DEMO</p>
<p>现代浏览器中 inline 和 block 元素 display:inline-block 后均会产生水平空隙；</p>
<p>IE6、7，IE8（Q）模拟 display:inline-block 后分两种情况：</p>
<p>IE6、7，IE8（Q）中：inline 元素会产生空隙，block 元素不会产生空隙。
看看 inline 元素默认的表现情况如何？原来默认就有空隙存在！它们是谁？是空白符（white space）！</p>
<p>W3C 9.1 White space 中规定以下元素属于空白符（white space）：</p>
<p>ASCII 空格 (&#x0020;)
ASCII 制表符 (&#x0009;)
ASCII 换页符 (&#x000C;)
零宽度空格 (&#x200B;)「这个在闭合浮动中也有运用到」
9.3.2 Controlling line breaks 中进一步阐述：</p>
<p>A line break is defined to be a carriage return (&#x000D;), a line feed (&#x000A;), or a carriage return/line feed pair. All line breaks constitute white space.</p>
<p>For more information about SGML’s specification of line breaks, please consult the notes on line breaks in the appendix.</p>
<p>折行被定义为一个回车符（&#x000D;），一个换行符 line feed (&#x000A;)，或者一个回车、换行的组合。所有的折行构成了空白符。</p>
<p>有关 SGML 规范中折行的更多信息，请参阅附录中关于折行的注释。</p>
<p>通常情况下，对于多个连续的空白符（空格，换行符，回车符等），浏览器会将他们合并为一个空白符。CSS 中由 white-space 这个属性来控制：</p>
<p>white-space：normal | pre | nowrap | pre-wrap | pre-line</p>
<p>默认值：normal</p>
<p>normal：默认处理方式。
pre：用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行。可查阅 pre 对象
nowrap：强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象。
pre-wrap：用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。
pre-line：保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。</p>
<p>注：IE7及更早浏览器不支持 CSS2.1 新增的 pre-wrap | pre-line。</p>
<p>所以这并不是 inline-block 后产生的 bug，而是因为 inline-block 具有 inline 元素固有的特性。那么为何 IE6、7 block 元素没有产生空隙呢？其实前面也提到了 IE 的 hasLayout，具有独立性，所以产生 hasLayout 的元素之间表现出来互不影响，这也再次表明 IE6、7 中的 inline-block 不能等同于 CSS2.1 中的 inline-block。如果非要说是有 bug， IE6、7 block 元素 inline-block 后不产生空隙才是 bug。</p>
<p>测试表明删除换行符后，inline 元素间的空隙就「消失」了：</p>
<p>2.去掉 inline-block 产生的空隙</p>
<p>为了让各个浏览器表现一致，更好的还原视觉设计搞，很多时候我们需要去掉 inline-block 产生的空隙。</p>
<p>上一节中我们已经知道产生空隙的根本性原因是：</p>
<p>HTML 中的换行符、空格符、制表符等产生了空白符，而这些归根结底都是字符，那么它们的大小都是 受 font-size 来控制的，字体大小直接导致 inline 或者 inline-block 后元素之间空隙的大小，把 inline-block 元素间的空隙认为总是某个固定大小是错误的。</p>
<p>用 GIF 动画的形式来表明对应关系：</p>
<p>很清楚的看到，当 font-size:0 的时候元素间的空隙都为0了，或许到这里你会感到很欣喜了，原来掌握的根本性原因这么简单就搞定了啊！</p>
<p>然，理想是丰满的，现实是骨感的。</p>
<p>大部分浏览器是支持 font-size:0 的。很明显，我们要和 IE 6、7 这两个妖孽进行一番战斗。</p>
<p>font-size:0 的支持情况</p>
<p>1）Chrome</p>
<p>低版本的 chrome 浏览器为了不让文字过小不利于阅读，默认是不支持 font-size:0 的，还好我们有 -webkit-text-size-adjust 这个私有属性来控制，当设为 none 时就支持字体大小为 0 了。我已经记不清楚 chrome 从哪个版本开始支持 font-size:0 了，反正我用 chrome 19 是支持了（有知道的朋友，烦请告诉一丝一声，最好有官方更新说明）。但是，-webkit-text-size-adjust:none; 会直接导致页面文字无法缩放，这对于用户来说显然是不友好的。所以-webkit-text-size-adjust:none; 一定要慎用，确保使用的地方没有大面积的文字。</p>
<p>-webkit-text-size-adjust:none 的使用场景实例参阅：<a href="http://vip.etao.com/">http://vip.etao.com/</a></p>
<p>2）Safari</p>
<p>Safari 5 依旧不支持 font-size:0 ，不过相信这些浏览器厂商都意识到了这个问题，在 Mac 平台最新的 Safari 6 已经很好的支持 font-size:0 了。</p>
<p>3）Firefox，Opera</p>
<p>经测试，Firefox12，Opera 10 ，这次表现不错，支持 font-size:0 。</p>
<p>4）IE</p>
<p>IE8 以上支持 font-size:0;
IE6、7 inline 元素 inline-block 后设置 font-size:0 始终有 1px 的空隙。
是不是一下子又开始头疼了？没关系，让我们请出 letter-spacing 和 word-spacing 二位大神。既然空白符也是字符，那么二位大神肯定是可以搞定它们的。</p>
<p>letter-spacing : normal | length （检索或设置对象中的文字之间的间隔）
word-spacing : normal | length（检索或设置对象中的单词之间插入的空隔）
normal： 默认间隔
length： 用长度值指定间隔，允许为负值。</p>
<p>还等什么，我们赶紧试试吧：</p>
<p>参照 DEMO</p>
<p>第一步：使用 font-size:0经测试发现，chrome、firefox、IE8+、opera，inline 或 block 元素都没有空隙了；
Safari 5.1.7 由于不支持 font-size:0 ，仍然存在空隙；</p>
<p>IE6、7、8（Q），inline 元素 inline-block 后始终存在 1px 左右的空隙。
第二步：处理 Safari 不支持 font-size:0 的问题上面已经指出 letter-spacing 是支持负值的，那么这个负值到底取多少合适呢？经过测试得出的结论是：inline-block 产生的空隙与父级元素继承或者设定的 font-family、font-size 有关，通常情况下，12px 大小的 tahoma 字体，inline-block 后元素间产生的空隙（间隙）大约是 5px；
各个字体详细情况请参阅《inline-block空隙–letter-spacing与字体大小/字体关系数据表》。</p>
<p>Firefox 中 letter-spacing 负值的绝对值大于空隙大小后，会导致元素整体位置向右偏移；</p>
<p>Safari 中 letter-spacing 负值的绝对值大于空隙大小后，内部会发生重叠。</p>
<p>第三步：修复 IE6、7 中始终存在的 1px 空隙
既然 letter-spacing 已经无能为力了，那就试试 word-spacing 吧，直接设置 word-spacing:-1px。这里需要注意的是，letter-spacing 和 word-spacing 同时使用可能导致冲突，所以我们需要在 IE6、7 中 hack 掉 letter-spacing。最终代码如下：
font-size:0;/<em> 所有浏览器 </em>/
letter-spacing:-5px;/<em> Safari 等不支持字体大小为 0 的浏览器 </em>/
<em>letter-spacing:normal;
word-spacing:-1px;/</em> IE6、7 */
第四步：子元素重置回正常值
上述所有操作都是在父元素设置的，那么子元素都会继承这些属性，字体大小为0了，子元素就什么都看不到了，这并不是我们想要的。 同时字符和单词间距我们也要把它重置为默认值。「font-size: 12px; letter-spacing: normal; word-spacing: normal;」
最后：inline-block 更好的复用
或许你会担心每次我都要去看字体和空隙之间大小的关系吗？其实不然，通常情况下，全局字体都已经在 body 中指定了，根据全局字体设置合适的 letter-spacing 负值即可。如此一来，我们便可以放心大胆的使用 inline-block 了，结合 OOCSS 的思想，可以抽离出两个复用的类，在需要设置 inline-block 元素的父级元素上定义一个「.dib-wrap」，该元素自身定义为「.dib」。这里还有一个问题需要注意的是：由于 inline-block 具有 inline 元素的特性，在垂直方向上很多时候我们并不希望元素以「vertical-align:baseline」方式来呈现，所以在「.dib-wrap」中统一重置为「vertical-align:top」即可。
3. 去除 inline-block 空隙终极解决方案（2012年8月17日更新）</p>
<p>.dib-wrap {
    font-size:0;/<em> 所有浏览器 </em>/
    <em>word-spacing:-1px;/</em> IE6、7 <em>/
}
.dib-wrap .dib{
    font-size: 12px;
    letter-spacing: normal;
    word-spacing: normal;
    vertical-align:top;
}
@media screen and (-webkit-min-device-pixel-ratio:0){
/</em> firefox 中 letter-spacing 会导致脱离普通流的元素水平位移 <em>/
.dib-wrap{
    letter-spacing:-5px;/</em> Safari 等不支持字体大小为 0 的浏览器, N 根据父级字体调节<em>/
}
}
.dib {
    display: inline-block;
    </em>display:inline;
    *zoom:1;
}
其实在 YUI 3 中也全面运用了 inline-block 作为基础布局，YUI 3 是这样解决的：</p>
<p>.yui3-g {
    letter-spacing: -0.31em; /<em> webkit: collapse white-space between units </em>/
    <em>letter-spacing: normal; /</em> reset IE &lt; 8 <em>/
    word-spacing: -0.43em; /</em> IE &lt; 8 &amp;&amp; gecko: collapse white-space between units */
}</p>
<p>.yui3-u {
    display: inline-block;
    zoom: 1; <em>display: inline; /</em> IE &lt; 8: fake inline-block */
    letter-spacing: normal;
        word-spacing: normal;
    vertical-align: top;
}
显然，这里纯粹使用了 letter-spacing 和 word-spacing 来控制元素间的空隙，局限性极大，-0.31em 和 -0.43em 只是因为 YUI 3 全局 cssfonts.css 里设置是：「body { font:13px/1.231 arial,helvetica,clean,sans-serif; }」。</p>
<p>当然，如果你坚持使用把 html 写在一行的方式来达到去除 inline-block 空隙的目的，我只能说：一切以牺牲结构来兼容表现的行为都是耍流氓！所以探讨此种方式去除空隙也将是无意义的，不在本文和作者考虑范围之内。</p>
<ol>
<li>结局——本文产生的一些观点如下：</li>
</ol>
<p>IE5.5 后开始支持 inline-block， 比 CSS2.1 更早提出 inline-block 的概念并作为所谓的「私有属性值」使用。但是它所支持的 inline-block 不能等同于 CSS2.1 中的 inline-block，IE 5.5、6、7 、8（Q）中 block 元素对 inline-block 支持不完整，因此二者表现出来的效果是不完全一致。
产生 inline-block 空隙的根本性原因是：HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，因此产生了元素间的空隙。
慎用 -webkit-text-size-adjust:none，它将会导致页面无法通过缩放来改变字体大小。
三、inline-block 未来</p>
<p>如今，Mac 平台下的 Safari 6 已经支持 font-size:0 了，相信很快 Windows 平台的 Safari 如果发布 5.X 的更新，也会支持字体为 font-size:0 了。等到 IE6、7 灭亡之后，世界就真真儿的美妙了！最后说一点：inline-block 与 float 也是无法直接比较的，请不要再讨论 inline-block 和 float 哪个更好的话题了。inline-block 从 IE5.5 一路走来，存在即是合理，以后有时间在总结一下 inline-block 与 float 的使用场景的区别。</p>
<p>在不改变 CSS 定位机制的前提下，inline-block 应该是首选，而不是以「奇淫技巧」存在的。有感打油诗一首：</p>
<p>网事如烟
CSS 红尘里
inline-block 知多少
你在这头
inline-block 在那头
用与不用
它就在那里
不悲不喜</p>
<p>PS：</p>
<p>为了更好的排版，本文使用繁体中文引号 「」代替简体中文小蝌蚪引号；
中英文混排的时候英文首尾各加一个空格；
以后文章有需要的时候也都将使用 gif 动画配合说明。
测试环境</p>
<p>操作系统版本:     Windows 7 企业版 6.1（内部版本 7600）
浏览器版本:    IE6
IE9
Firefox 14.0.1
Chrome 19.0.1084.46
Safari 5.1.7(7534.57.2)
Opera 12.50
最后更新时间:     2012-8-17</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/03/25/css-clearfix/">清除浮动的方法</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-03-25T12:57:29.000Z">3月25 2013</time>
      
    </header>
    <div class="entry">
      
        <p>float是网页布局中最常用的css属性之一，但是使用float同样会带来各种各样的问题，例如它使元素脱离正常的文档流，使父元素的高度坍塌等，所以我们经常要清除浮动。</p>
<p>现在，越来越多人反对使用float来布局，最具代表性的就是google，因为float布局是会产生各种问题，有事问题还是莫名其妙的，而且使用display: inline-block能够完成大多数float能完成的布局。但某些方面，display: inline-block并不能代替float，例如float的方向性，float依然是常用的布局属性之一，所以清除浮动不可避免。</p>
<p>清除浮动的方法很多，不过从分类来说，清除浮动的方法可以分成两类：</p>
<p>1.利用 clear 属性。
2.触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)。</p>
<p>常用的清除浮动方法</p>
<p>1.添加额外标签</p>
<p>这是比较古老一种方法，通过在浮动元素末尾添加一个空的标签然后使用clear:both。</p>
<p>3)父元素设置 overflow</p>
<p>.main{float:left;}
.side{float:right;}
.footer
优点：通俗易懂，容易掌握。
缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦。</p>
<p>2.overflow 方法</p>
<p>通过设置父元素overflow值设置为hidden触发浮动元素父元素的 BFC；在IE6中还需要触发 hasLayout ，例如 zoom：1,使用方法如下：</p>
<p>3)父元素设置 overflow</p>
<p>.main{float:left;}
.side{float:right;}
.footer
优点：不存在结构和语义化问题，代码量极少。
缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<p>3.使用 :after 伪元素的方法</p>
<p>主流的用法如下：</p>
<p>/<em> 清理浮动 </em>/
.clearfix:after {
    visibility:hidden;
    display:block;
    font-size:0;
    content:&quot; &quot;;
    clear:both;
    height:0;
}
.clearfix {
    zoom:1;
}
这是现在主流的清理浮动方式。</p>
<p>&quot;那些年我们一起清除过的浮动&quot;提到两种更简洁的清除浮动方法：</p>
<p>方案一：</p>
<p>相对于空标签闭合浮动的方法代码似乎还是有些冗余，通过查询发现Unicode字符里有一个“零宽度空格”，也就是U+200B ，这个字符本身是不可见的，所以我们完全可以省略掉 visibility:hidden了。</p>
<p>.clearfix:after 
{
        content:&quot;\200B&quot;;
        display:block;
        height:0;
        clear:both; 
}
.clearfix {
        *zoom:1;
 }
方案二：</p>
<p>由Nicolas Gallagher 大湿提出来的,原文:A new micro clearfix hack，该方法也不存在firefox中空隙的问题。</p>
<p>/<em> For modern browsers </em>/
.cf:before,.cf:after {
        content:&quot;&quot;;
        display:table;
}
.cf:after { 
        clear:both; /<em> For IE 6/7 (trigger hasLayout) </em>/
}
.cf {
        zoom:1; 
}
上面的方法用到了  ：before伪元素，很多人对这个有些迷惑，到底我什么时候需要用before呢？为什么方案一没有呢？其实它是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加。如果这不是你所希望的，那么就可以加上before，如果只是单纯的闭合浮动，after就够了！并不是如同大湿《Clear Float》一文所说的：但只使用clearfix:after时在跨浏览器兼容问题会存在一个垂直边距叠加的bug，这不是bug，是BFC应该有的特性。</p>
<p>推荐阅读</p>
<p>那些年我们一起清除过的浮动
清理浮动的几种方法以及对应规范说明
更简洁的 CSS 清理浮动方式</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/03/20/css-bfc/">CSS BFC(Block Formatting Context)</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-03-20T12:57:29.000Z">3月20 2013</time>
      
    </header>
    <div class="entry">
      
        <p>BFC的定义</p>
<p>BFC是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。BFC在创建了 Block Formatting Context 的元素中，其子元素会一个接一个地放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻的元素之间的垂直距离取决于‘margin’ 特性。在 Block Formatting Context 中相邻的块级元素的垂直边距会折叠（collapse）。</p>
<p>在 Block Formatting Context 中，每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）， 即使存在浮动也是如此（尽管一个元素的内容区域会由于浮动而压缩），除非这个元素也创建了一个新的Block Formatting Context 。</p>
<p>BFC到底是什么？</p>
<p>当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。</p>
<p>怎样才能形成BFC</p>
<p>float的值不为none。
overflow的值不为visible。
display的值为table-cell, table-caption, inline-block中的任何一个。
position的值不为relative和static。
BFC的作用</p>
<p>1.不和浮动元素重叠</p>
<p>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子</p>
<p>123
The quick brown fox jumped over the lazy dog&#39;s back. The quick brown fox jumped over the lazy dog&#39;s back. The quick brown fox jumped over the lazy dog&#39;s back. The quick brown fox jumped over the lazy dog&#39;s back. The quick brown fox jumped over the lazy dog&#39;s back.</p>
<p>2.清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。</p>
<p>3.嵌套元素Margin边距折叠问题的解决</p>
<p>按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。</p>
<p>因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。</p>
<p>摘自：<a href="http://www.w3cmm.com/other/css-bfcblock-formatting-context.html">http://www.w3cmm.com/other/css-bfcblock-formatting-context.html</a></p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/03/18/iehaslayout/">IE Haslayout</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-03-18T12:57:29.000Z">3月18 2013</time>
      
    </header>
    <div class="entry">
      
        <p>我们们那知道浏览器有bug，而且Windows上的lE的bug 似乎比太多数浏览器都多。IE/Win的衣现与其他浏览器不同的原因之一是，显示引擎使用一个称为布局(layout)的内部概念。因为布均是一个专门针对显示引擎内部工作方式的概念，所以一般悄况下不需要了解它。但是，布局问题是许多IE/Win显示bug的根源，所以理解这个概念以及它如何影响CSS是有捂助的。</p>
<p>什么是布局</p>
<p>Windows 上的IE 使用布局概念来控制元素的尺寸和定位。那些称为拥有布局(have layout)的元素负责本身及其子元素的尺寸和定位。如果一个元旦在没有拥有布局，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。</p>
<p>IE 显示引擎利用布局概念减少它的处理开销。在理想悄况下，所有元素都控制自己的尺寸和定位。但是，这会在IE中导致很大的性能问题。因此，IE/Win开发团队决定只将布局应用于实际需要它的那些元素，这样就可以充分地减少性能开销。</p>
<p>在默认情况下拥有布局的元素包括:</p>
<p>body
标准模式中的 html
table
tr, td
img
hr
input, select, textarea, button
iframe, embed, object, applet
marquee
布局概念是Windows 上的I E 特有的，而且它不是CS S 属性.尽管某些CSS 属性会使元ffi拥有布局，但是在CSS 巾无法显式地设宣布局.可以使用JavaScript函数hasLayout 查看一个元亲是否拥有布局.如果元素拥有布局，这个函数就返回true ; 否则返回falseo hasLayout 是一个只读属性，所以无法使用JavaScript选行设置.</p>
<p>设宜以下CSS 属性会自动地使元亲拥有布局·</p>
<p>position: absolute
float: left or right
display: inline-block
width: any value
height: any value
zoom: any value (Microsoft property—doesn’t validate)
writing-mode: tb-rl (Microsoft property—doesn’t validate)
布局有什么效果?</p>
<p>布局是许多IElWin 显示bug 的根源。例如， 如果一个文本段落靠谷一个浮动元索，那么期望文本围绕这个元索。但是，在Windows 上的1E
6 和更低版本巾，如果段落拥有布局(例如，由于设置了高度).那么它就被限制为矩形，因此阻止文本国绕浮动元素〈见图9-5).</p>
<p>Figure Above:</p>
<p>期望文本围绕相邻的浮动元素，但是，在IE/Win上，如果文本元素拥有布局，就不会这样显示。</p>
<p>这会导致浮动布间的各种问题更糟的是，许多人使用IE 作为主浏览器，他们会俯误地认为这才是正确的表现，在其他浏览器以不同方式处理泞-动元素时，他们反而会这必不解.</p>
<p>另-个问题涉及拥有布局的元素如何确定自己的尺，如果元亲的内容变得比元素本身大，那么期望元素流出到元素外.但是，在Windows 上的IE 6
和更低版本中，拥有布局的元素会销误地扩展以便适应内容的尺寸(见图9-6).</p>
<p>Figure Above:</p>
<p>拥有布局的错误的扩展以便适应内容</p>
<p>这意味IE/Win中的width 实际上更像min-width. 这种行为也是在IE/Win中许多浮动布局被破坏的原因。当浮动框的内容错误地迫使框的宽度增加时，框对于可用空间来说太大了，因此下降到其他浮动元素在下面.</p>
<p>其他问题包括:</p>
<p>拥有布局的元素不进行收缩。
布局元亲对浮动进行自动消理。
相对定位的元素不获得布局。
在拥有布局的元素之间空白地不叠加。
在不拥有布局的块级链接上，单击区域只覆盖文本。
常见bug及其修复方法</p>
<p>CSS 开发人员最重要的技能之一是发现常见浏览器bug的能力。通过了解导致这些bug 的各种元索，可以在它们造成问题之前发现并且修复它们。</p>
<p>双空白边浮动bug</p>
<p>最常见且最容易发现的bug 之一是IE6和更低版本中的双空白边浮动bug。顾名思义，这个Windows bug使任何浮动元素上的空白边加倍(见图9-7)。</p>
<p>Figure Above:</p>
<p>IE/Win 的双空白浮动bug示意阁</p>
<p>这个bug 很容易修复，将元素的display 属性设置为inline 就行了.因为元素是浮动的，将display 属性设置为inline，实际上不会影响显示方式。但是，这似乎会阻止Windows 上的IE6和更低版本将所有空白地加倍。这是一个非常容易发现和修复的bug : 每当对具有水平空白边的元素进行浮动时，都应该很自然地将display属性设置为inline。</p>
<p>3像素文本偏移bug</p>
<p>另一个非常常见的I E 5-61Win bug 是3像素文本偏移bug。当文本与二个浮动元示相邻时，这个bug 就会表现出来。例如，假设将-个元素向左浮动，并且不希望相邻段落中的文本围绕浮动元素。你可能会在段落上应用一个左空白边，其宽度等于浮动元素的宽度:</p>
<pre><code><figure class="highlight"><pre>    <span class="class">.myFloat</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> left;</span></span> <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px;</span></span> <span class="rule">}</span></span>
    <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">200</span>px;</span></span> <span class="rule">}</span></span>
</pre></figure></code></pre>
<p>如果这么做，在文本和浮动元素之间就会出现一个莫名其妙的3像素间隙。(见图9-8) 。</p>
<p>Figure Above:</p>
<p>IE 5-6/Win 的3像素文本偏移bug示意图</p>
<p>修复这个bug 需要双管齐下。首先，给包含文本的元素设置任意的高度。这会迫使元素拥有布局，这在表面上会消除文本偏移。因为Windows 上的IE6和更低版本将height作为min-height那样对待，所以设置一个小的高度并不会影响元素在这些浏览器巾的实际尺寸。但是，这会影响其他浏览器，所以要使用Holly招数对除了Windows上的IE6 和更低版本之外的所有其他浏览器隐藏这个规则，</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">/* Hide from IE5-Mac. Only IE-Win sees this. \*/</span>
    * <span class="tag">html</span> <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule">}</span></span>
    <span class="comment">/* End hide from IE5/Mac */</span>
</pre></figure></code></pre>
<p>不幸的是，这么做会导致另一个问题。正如在前面学到的，拥有布局的元素被限制为矩形的，并且出现在浮动元索的旁边而不是它们的下面。添加200像素的空白边实际上会在IE5-6/Win 中在浮动元素和段落之间产生200像素的间隙。为了边免这个问隙，需要将IE 5-6/Win 上的空白边重新设置为零:</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">/* Hide from IE5-Mac. Only IE-Win sees this. \*/</span>
    * <span class="tag">html</span> <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0</span>;</span></span> <span class="rule">}</span></span>
    <span class="comment">/* End hide from IE5/Mac */</span>
</pre></figure></code></pre>
<p>文本偏移被修复了，但是现在另一个3像亲间隙出现了，这一次是在浮动元素上。为了去掉这个问隙，需要在浮动元素上设置一个负值的3像素右空白边：</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">/* Hide from IE5-Mac. Only IE-Win sees this. \*/</span>
    * <span class="tag">html</span> <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0</span>;</span></span> <span class="rule">}</span></span>
    * <span class="tag">html</span> <span class="class">.myFloat</span> <span class="rules">{ <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> -<span class="number">3</span>px;</span></span> <span class="rule">}</span></span>
    <span class="comment">/* End hide from IE5/Mac */</span>
</pre></figure></code></pre>
<p>如果浮动元素是除了图像之外的任何其他东西，那么这个问题己经修复了。但是，如果浮动元旦在是图像，那么还有放后一个问题需要解决。 IE 5.x/Win在图像的左右都添加3像亲的间隙。而IE6不改变图像的空白边。因此，需要用另一个招术在IE5.x/Win 上去掉3 像素的问隙:</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">/* Hide from IE5-Mac. Only IE-Win sees this. \*/</span>
    * html p { height: <span class="number">1</span>%<span class="comment">; margin-left: 0; }</span>
    * html img<span class="preprocessor">.myFloat</span> { margin: <span class="number">0</span> -<span class="number">3</span>px<span class="comment">; ma\rgin: 0; }</span>
    <span class="comment">/* End hide from IE5/Mac */</span>
</pre></figure></code></pre>
<p>这会解决问题，但是采用的方式很难看而且太复杂。因此，如果可能的话，最好将这些规则分别放进单独的浏览器特定的样式表中。如果这样做，用于Windows上的lE 5.x的样式表如下：</p>
<pre><code><figure class="highlight"><pre>    <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0</span>;</span></span> <span class="rule">}</span></span>
    <span class="tag">img</span><span class="class">.myFloat</span> <span class="rules">{ <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> -<span class="number">3</span>px;</span></span> <span class="rule">}</span></span>
</pre></figure></code></pre>
<p>用于IE 6的样式表如下:</p>
<pre><code><figure class="highlight"><pre>    <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">0</span>;</span></span> <span class="rule">}</span></span>
    <span class="tag">img</span><span class="class">.myFloat</span> <span class="rules">{ <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span>;</span></span> <span class="rule">}</span></span>
</pre></figure></code></pre>
<p>IE 6躲躲猫bug</p>
<p>另一个奇怪而且很烦人的 bug 是IE6 的躲躲猫(peek-a-boo) bug，之所以起这个名称是因为在某些条件下文本看起来消失了，只有在前新装载页面时才再度出现。出现这个bug的条件是:一个浮动元素后面跟着一些非浮动元素，然后是一个清理元素，所有这些元素都包含在一个设置了背景颜色或阅像的父元束中。如果清理元素碰到了浮动元素，那么中间的作浮动元素看起来消失了，隐藏到了父元素的背景颜色或图像后面，只有在刷新页面时才重新出现(见图9-9)。</p>
<p>Figure Above:</p>
<p>IE 6的躲躲猫bug示意图</p>
<p>相对容器中的绝对定位</p>
<p>我要讨论的段后一个主要浏览器bug涉及相对定位容器中的绝对定位元素。在前面的章节中你学到将绝对定位的元素嵌套在相对容器中是多么有用。但是，IE6和更低版本在使用这种技术时有许多bug。</p>
<p>这些bug 的原因在于相对定位的元素没有获得IE/Win 的内部hasLayout 属性。因此，它们不创建新的定位上下文，所有绝对定位元素相对于窗口进行定位(见图9-10)。</p>
<p>Figure Above:</p>
<p>IE5.x对相对容器中的绝对定位元素的定位方式不正确</p>
<p>为了使Windows 上的IE 6和更低版本的表现正确。需要迫使相对应位的容器拥有布局。一种方法是在容器上显式地设置width 和height。但是，常常希望在不知道容器的width和height的况下，或者在需要这些属性保持灵活的情况下使用这种技术。</p>
<p>可以使用Holly 招数为容器提供一个的高度。这会让容器拥有布局。但是因为IE 6和更低版本中的元素会不正确地扩展以适应它们的内容，所以设置小的高度不会影响实际高度。</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">/* Hides from IE-Mac \*/</span>
    * <span class="tag">html</span> <span class="class">.container</span> <span class="rules">{ <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1</span>%;</span></span> <span class="rule">}</span></span>
    <span class="comment">/* End hide from IE-Mac */</span>
</pre></figure></code></pre>
<p>停止对IE 的批评</p>
<p>IE 并不足惟一一种有bug 的浏览器，所以你可能会奇怪我为什么只关注IE bug。 不必担心，我找并不是专门和微软过不去，这么做是有理由的。</p>
<p>首先， IE 目前占有最大的浏览器市场份额。因为有许多人在使用IE，IE bug 往往很快被发现而且很好地记录下来。当在IE中发现一个重大的CSS
bug时，许多开发人员会尝试寻找修复方法或解决方案。由于IE的流行程度，被记录并修复的IE bug比其他任何浏览器都要多.</p>
<p>另一个主要问题是开发的节奏。Firefox、Safari和Opera等浏器不断地进行更新，新版本以非常高的频率出现。 bug 几乎一经发现就被修复了，并且发布浏览器的新版本.因此，现在讨论的任何Firefox或Safari bug 可能已经被下一个修订版修复了。</p>
<p>如此高的开发节奏确实很棒，但是也有自己的问题。开发人员要应付的浏览器版本不是两三个，而是20或30个。你无法确定用户是否使用最新的版本，这使测试变得极其困难。另一方面，IE差不多5年没有发布主要修订版了。因此，bug有更多的时间可以暴露出来，开发人员也有更强的寻找修复方法的动力。</p>
<p>幸运的是，IE 7承诺将成为更符合标准的浏览器。许多著名的IE bug 已经被解决，而且对高级CSS 2.1 选择器（比如子选择器和属性选择器）的支持也在增加。与所有浏览器一样，新的bug也会出现，IE7远不是完美的。但是，人们越快地升级到IE 7和Firefox 等现代浏览器，IE 5.0等老式浏览器就会越快地退役。</p>
<p>在这个过渡时期，可以考虑使用Dean Edwards 的IE 7 补丁。这是一系列JavaScript 文件，它们使IE 5-6/Win 能够接近IE7的水平.这包括改进的选择器实现和许多bug 修复。关与这个补丁的更多信息，请访问 <a href="http://dean.edwards.name/IE7/">http://dean.edwards.name/IE7/</a></p>
<p>摘自：<a href="http://adamghost.com/2009/03/ie-has-layout-and-bugs-zh/">http://adamghost.com/2009/03/ie-has-layout-and-bugs-zh/</a></p>
<p>下面是我收集到的关于IE Haslayout的文章,通过阅读这些文章，可以更加深入理解Haslayout：</p>
<p>HasLayout Overview
IE Haslayout 详解
IE hasLayout的问题总结
On having layout</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/03/02/css-bottleneck/">打破CSS学习瓶颈</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-03-02T12:57:29.000Z">3月2 2013</time>
      
    </header>
    <div class="entry">
      
        <p>最近读到一篇关于CSS学习的文章，叫做“说说CSS学习中的瓶颈”。作者张鑫旭谈到了在学习CSS过程中会遇到怎样的瓶颈，并给出了打破瓶颈的一些方法。</p>
<p>根据作者的描述，处于瓶颈的人可有以下特点：
        1.能根据设计图迅速成型页面，能熟练使用些CSS hack
        2.花时间学习了，纯粹经验积累，没有学到多少实质性的东西
        3.知道大部分CSS属性的用法，但不知道其中的原理
对比自己，感觉自己现在就是处于瓶颈期。接触CSS快两年了，当初对编程一窍不通，是CSS把我引上了路，这里要感谢CSS。一直都认为：熟悉大多CSS的属性和用法，不懂时能快速的查找相关文档；能搞快速实现自己想要的布局，能够快速实现想要的效果和样式；能写出兼容大多数浏览器的代码，遇到不兼容是能够通过各种尝试解决之。一直都认为对CSS的使用这样就够了。现在仔细想想，自己是大错特错了，曾经有多少次，自己被各种莫名其妙的浏览器搞得焦头烂额，有时解决一个所为的bug可能就要耗去一个上午，因为我根本就没去探究各种不兼容性的本质，而是去尝试各种方法，最后就算找到了解决方法，也花去大多数时间。效率低下不说，最可怕的是，这样的做法是导致我一直在给代码打补丁，发现问题就解决问题，永远没有明白其中的机制。</p>
<p>所以，从今天开始，没遇到一个问题，首先要问自己为什么会这样？这段代码在各个浏览器表现不一样的原因什么？要学会去探其究竟，做到深入理解其机制。其实，使用JavaScript时也一样，我们不能总是依赖类库，而要把基础打好，踏踏实实学好原生的JavaScript。</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/02/28/get-javascript-url/">Javascript获取url的参数</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-02-28T12:57:29.000Z">2月28 2013</time>
      
    </header>
    <div class="entry">
      
        <p>在Web开发中，经常会用url传递一些参数，用Javascript获取url参数很简单，主要使用split()把url分割成数组，然后就可以使用参数了。方法为了方便快速的获取url中的参数，也为了以后代码的重用，我把它写成一个函数，把获取的参数集合存在一个对象里。</p>
<p>实现代码如下：</p>
<pre lang="javascript">var  UrlParameters  =  function()  {
        var  url  =  window.location.search,// 获取url中"?"和"?"后面的字符串
                args, arg,
                back  =  {}; // 定义一个对象用来储存获取参数

        if(url == '') return 0; //如果url没有任何参数，返回0

        if( url.indexOf('?')  !=  -1 ) { // 如果url存在参数 
                args  =  url.substr(1).split('&amp;'); // 分割各个参数
                for (var  i  =  0,; i  &lt;  args.length;  i++) {
                        arg  =  args[i].split('=');
                        back[ arg[0] ]  =  arg[1]; // 把每对参数都存在对象中
                };
        }

return back;
};</pre>
使用方法很简短，只要在Javascript中直接调用就行了，如下：
<pre lang="javascript">// 假设url为 http://www.hello.com?a=123
var myUrlParameters  =  getUrlParameters();
alert(myUrlParameters.a); // alert出123</pre>
      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/02/25/javascript-mobile/">JavaScript识别移动设备系统和浏览器类型</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-02-25T12:57:29.000Z">2月25 2013</time>
      
    </header>
    <div class="entry">
      
        <p>在实习期间，一直在移动设备上做开发，现在实习已经结束了，最近也比较闲，所以，想把实习期间，用到的一些比较细的JavaScript知识点记录总结一下。</p>
<p>今天要记录的知识点是，如何用JavaScript识别移动设备的系统类型和移动设备中的浏览器类型。要说的是，识别移动设备的系统类型和识别移动设备中的浏览器类型是两个不同的概念。</p>
<p>识别代码如下，为给更好的模块花，这里我把它放进一个对象里去：</p>
<p>Check  =  {
        //以下三句代码识别浏览器类型
        isWebkit  =  (/webkit/i).test(navigator.appVersion), //识别webkit
        isFirefox  =  (/firefox/i).test(navigator.userAgent), //识别moz
        isTrident  =  (/trident/i).test(navigator.userAgent), //识别ms</p>
<pre><code><figure class="highlight"><pre>    <span class="comment">//以下三句识别操作系统类型</span>
    isAndroid  =  (/android/gi)<span class="variable">.test</span>(navigator<span class="variable">.appVersion</span>), <span class="comment">//识别Android os</span>
    isIos  =  (/iphone|ipad/gi)<span class="variable">.test</span>(navigator<span class="variable">.appVersion</span>), <span class="comment">//识别ios</span>
    isPlaybook  =  (/playbook/gi)<span class="variable">.test</span>(navigator<span class="variable">.appVersion</span>); <span class="comment">//识别Playbook os</span>
</pre></figure></code></pre>
<p>}
识别返回值是boolean类型，用法如下：</p>
<p>if(Check.isAndroid) {
        alert(&quot;this is android&quot;);
}</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/02/23/ordinary-world/">《平凡的世界》：不平凡的人生</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-02-23T12:57:29.000Z">2月23 2013</time>
      
    </header>
    <div class="entry">
      
        <p>在三天的多的时间里，没日没夜的把路遥的《平凡的世界》看完了。在看之前，真不知到这部小说如此之长，打开百度百科，才知道这部小说有1264页，100多万字。看电子书比较累，但现在庆幸自己看得是电子书，不然我早就被厚如砖头的书给吓住了，因为我一直抵触看很厚的书。现在看来，不想看厚书只是心理作用，其实我根本没那么怕看厚书。</p>
<p>在看《平凡的世界》之前，我一直再看krug的《don&#39;t make me think》，不到150页的书，四天还没看完，在当时的状态实在看不下去了，所以就想那本小说看看，于是就开始看《平凡的世界》，刚看没多久就无法自拔了，没日没夜不到四天就把它看完了。</p>
<p>这是一部现实主义小说，故事发生在改革开放前后的十几年中，里面描绘了西北农村在这段时间的变迁，从公社化到土地责任承包制，里面有很多人物角色，孙少安、孙少平、田晓霞、田福军...里面交织带着亲情和爱情、追求和挫折、痛苦和欢笑、爱与恨、哭与笑...一切一切，这就是平凡的世界，但是平凡的世界中同样能活出不平凡的人生，如靠已经自己的努力摆脱平穷的孙少安，如正在追求理想不向生活屈服的孙少平。</p>
<p>我自己也是从农村长大的，家里世代都是农民，从小时候奶奶就给我讲过公社化，所以能很好的理解当时的时代背景。里面发生的很多事，不会感觉陌生无法理解，反而有些似曾相识，虽然我出生在90年代，原来我还是一个90后啊。</p>
<p>里面人物角色众多，个个性格鲜明：心系家人的孙少安，为梦想奋斗的孙少平，性格明朗的田晓霞，懂事的孙兰香，讲义气的金波...我发现自己的成长环境和成长经历个里面一个角色很像，她叫兰香，她也是在我看书过程中感动过我的人之一。我跟她一样，来自不富裕的农村家庭，从小能认识到家里的难处，很懂事，从小主动帮家里做能做的农活家务，每次看到她主动出去捡才柴禾的情节，就不由想起自己小时候上山捡柴草的画面。同样，我跟她一样，从小在所在的学校成绩名列前茅，最后顺利考试一间重点大学，当然，现在重点大学比不上当时的重点大学。每次想起兰香那句“妈，猪我一经喂过了...”,我就有一股想哭的冲动，我知道那是我被感动了。</p>
<p>我最新欢的人物角色，可能跟大多数人一样，是主人公孙少平。他是作者开头就描写的人物，同样也是结尾描写的人物，我想我废话了，正常情况开头结尾都是描写主角的。孙少平有很多优秀的特质，我最欣赏的一个是，他敢于追求自己的理想，追随自己的内心，虽然在其他人看来是不理性。从选择离开双水村，去大城市闯荡到拒绝兰香的好意，不留在原城而是回去大牙湾掏煤，孙少平一直都直面自己的内心，去追求自己想要的东西。孙少安在面对他和田润叶的爱情时，选择理性，其实也是一种逃避和向世俗低头。孙少平在面对他和田晓霞的爱情时，直面自己的内心，敢于去追求，虽然她和田晓霞的爱情以悲剧结束，但在晓霞死前他们是幸福的。
有人说，不明白为什么孙少平最后为什么不留在原城，而是选择回铜城，成为一个安于现状的煤矿工人。我想说的是，他不留在原城，是要去继续的为他的理想奋斗，他并没有成为一个安于现状的煤矿工人，根据小说的暗示，他的理想应该是改变中国当前落后的挖煤技术水平。我有不由想起自己，家里人都叫我去考公务员，但当公务员真的不是我想要的生活，所以我不会去考公务员。在去年回到家时，我们村有个当官的，住在离我家不远，是我们县的财政局局长，也是一个好官，到我家跟我父母和我说，愿不愿意回我们县，他可以提供一个不错的单位给我，因为他知道我在一间不错的大学读书，也快毕业了，最后我拒绝了，因为这不是我内心所追求的。我知道我如果接受这位局长的好意，我以后可能会在体制内混得不错，不会愁吃穿住，对我的家人也更好，但我不能背叛自己的内心，在这希望父母能原谅在这方面的自私，也对关心的局长衷心的说声谢谢。</p>
<p>最后，我知道少平的理想会实现的，他也最终会和秀走在一起，路遥，你说是不是？</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  
    <article class="post">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="post-title"><a class="inner-post-title" href="/2013/02/16/dont-make-me-think/">Don't make me think(读书笔记)</a></h1>
  


      
        <div class="icon"></div>
        <time datetime="2013-02-16T12:57:29.000Z">2月16 2013</time>
      
    </header>
    <div class="entry">
      
        <p>krug可用性定律：</p>
<p>第一定律：don&#39;t make me think</p>
<p>第二定律：点击多少次都没关系，只要每次点击都无需思考、明确无误的选择。</p>
<p>第三定律：去掉每个页面上上一半的文字，然后把剩下的文字再去掉一半。（即省略不必要的文字）</p>
<p>也许一些习惯用法会发生变化，但有一件事情永远不会改变，那就是————人的本性。</p>
<p>为什么东西总是在你找的最后一个地方找到？因为你找到以后就不会再找。</p>
<p>我们认为的“精心准备的文字”（或者至少是“产品资料”）在用户看来更像“以每小时100公里的速度驶过的广告牌”。</p>
<p>第一个事实：我们不是阅读，而是扫描。</p>
<p>第二个事实：我们不做最佳选择，而是满意即可。</p>
<p>事实上，大多数时间里我们不会选择最佳选项，而是选择第一个合理的选项，这就是满意策略。一旦我们发现一个链接，看起来似乎能跳转到我们想要去的地方，那就是一个我们将要点击它的大好机会。</p>
<p>第三个事实，我们不是追根究底，而是勉强应付。</p>
<p>如果用户们都是疾驰而过，那么，你需要注意以下五个重要方面，来保证他们可能地看到了并了解你的网站。</p>
<p>在每个页面上建立清除的视觉层次。</p>
<p>尽量利用习惯用法。</p>
<p>把页面划分成明确定义的区域。</p>
<p>明显标识可以点击的地方。</p>
<p>最大限度降低干扰。</p>
<p>省略多余的文字，</p>
<p>有力的文字都很简练，句子里不应该有多余的文字，段落中不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。</p>
<p>当我浏览网页的时候，发现大多数页面上的大部分文字都只不过是占地方，因为没人打算阅读它们，但因为它们确实在那儿，所以这些多余的文字都在暗示你可能真的需要阅读它们理解到底是怎么回事，这样常常使得页面看起来难度更高了。</p>
<p>如果在网站上找不到方向，人们不会使用你的网站。</p>
<p>为什么Web设计团队讨论可用性是浪费时间，如何避免这种情况。</p>
<p>我常常把这种无休止的讨论称为“信仰大战”，因为这种讨论跟大部分的宗教和政治讨论有很多相同之处：它们由大量无法验证的个人信仰组成————大体上是为了某些重要问题的最好做法上取得一致（不管是永久和平、政府效率，或者只是网页设计），而且，和大多数的信仰大战一样，它们很少能让人改变它们原来的看法。</p>
<p>除了浪费时间，这些争论也产生紧张气氛，破坏团队成员之间的关系，常常让团队无法做出关键决定。</p>
<p>遗憾的是，有一些因素存在大部分的Web团队中，让这些辩论几乎无法避免，在这一章，我将讲述这些因素，并解释我认为最好的解决方法。</p>

      
    </div>
    <footer>
      
        
        
      
    </footer>
  </div>
</article>




  

  <nav id="pagination">
  
  
    <a href="/archives/2013/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div>
        </div>
        <footer id="footer" class="footer">
    
    &copy; 2013 forisnger
    
</footer>

        
    </section>
</body>
</html>
